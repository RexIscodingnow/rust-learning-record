Rust 學習

副檔名: 名稱.rs

一、 基本設置 與 Cargo 命令

創建 rust 專案  ==>  Cargo

1. 創建程式碼 (或叫代碼)、下載依賴的程式庫
2. 命令行

    2-1. 版本查詢 => cargo --version
    2-2. 專案新增 => cargo new 專案 (資料夾)
    2-3. 構建 (編譯) Cargo 項目 => cargo build
            2-3-1. 創建可執行檔案 => 目標路徑: ./target/debug/檔名.exe  (Windows)
            2-3-2. 執行編譯執行檔 => 目標路徑: ./target/debug/檔名.exe  (Windows)

    2-4. 構建 (編譯) 和 執行 => cargo run

    2-5. 第一次編譯，會生成 Cargo.lock 的檔案

    2-6. 檢查程式碼 (確認能通過編譯) => cargo check
            2-6-1. 用來確認是否可編譯通過，"但不會生成 執行檔案"
    
    2-7. 為發布構建 => cargo build --release
            2-7-1. 編譯時，會進行優化。執行速度會更快，但是編譯時間更長
            2-7-2. 生成的路徑會在 target/release 底下，而不是 target/debug 生成
            2-7-3. 編譯配置有兩種
                        1. 開發中
                        2. 正式發布 (該命令，屬於這類型)

3. 其他檔案 (檔案路徑配置圖)

    3-1. 生成檔案
            |--> 1. src 資料夾 => 存放 rust 程式碼
            |
            |--> 2. Cargo.toml => Cargo 的配置檔案
            |                               |--> [package]
            |                               |       |--> 說明: 一個區域標題，下方內容是用來配置包 (package) 的
            |                               |       |
            |                               |       |--> name: 項目名稱
            |                               |       |--> version: 版本
            |                               |       |--> authors: 項目作者
            |                               |       |--> edition: 使用的 Rust 版本
            |                               |
            |                               |--> [dependencies]
            |                               |       |--> 說明: 另一個區域的開始，這個會列出項目的依賴項
            |                               |
            |                               |--> 在 Rust 裡面，程式庫 (代碼包) 稱作 crate
            |
            |--> 3. gitignore => git 倉庫
            |
            |--> 4. Cargo.lock => 負責追蹤項目依賴的 精確版本，"不需要手動修改該檔案"
            |
            |--> 5. target 資料夾 => 編譯生成檔案都在這裡


二、 Rust 語法

1. 程式進入點
    fn main() {
        執行區;
    }

2. 宣告變數
    2-1. 常數(量): 屬於 Rust 預設的， " 具有不可變動性 "
        2-1-1. 不可以使用 mut 關鍵字
        2-1-2. 宣告 常數(量) 使用 const，它的型別必須備標註
        2-1-3. 常數(量) 可以在任何作用域，包含 全域作用域
        2-1-4. 只可以綁定到 常數(量) 表達式，無法綁定到函式的調用結果
                        或只能在運行，才能計算出的值

            示例: 1. let 變數名 = 值;
                  2. const 變數名(大多字母大寫表示) : u32 = 100_000;

    2-2. 一般變數: 數值可變動
            示例: let mut 變數名 = 值;

    2-3. 隱藏 (shadowing)
        2-3-1. 可以宣告同名稱的變數名，新的變數就會 " 隱藏 " 之前宣告的同名變數
        2-3-2. 在後續的程式碼中，同名變數就是代表新的變數

        2-3-3. ** shadow 和 把變數標記為 mut 是不一樣的 **
                    1. 如果不使用 let 關鍵字，那麼重新給 "不是 mut 的變數" 賦值，會導致編譯錯誤
                    2. 而使用 " let 宣告的 同名變數 "，也是不可變的
                    3. 使用 let 宣告的同名變數，它的 " 型別可以與之前不同 "
                        示例: 
                              1 | let x = 5; 
                              2 | let x = x + 2;
                              3 | let x = x - 7;

     2-4. 資料基本型別 (Data Type)

        ** 型別註釋 **
        Rust 是靜態型別語言，要先具體指定所需型別，會在編譯時被檢查。
        那如果未具體指定，卻可以編譯過去，是因為 Rust 有 "型別推斷" 的功能，
        如果它能判斷某變數型別，其實不太需要明確指明

        要指定該變數型別，要在變數後方加上 : 號，並指定
                示例:
                        1 | let x: i32 = 5;

        2-4-1. 整數
                    1. 例如 u32 是 "32 位元 無號整數"
                    2. 無號整數 (沒有負數) ，是以 " u " 開頭
                    3. 有號整數 (有負數)，是以 " i " 開頭
                    4. Rust 整數表
                                __________________________________________________
                                Size (位元)    Signed        Unsigned        範圍
                                __________________________________________________
                     (Byte) =>  8-bits          i8             u8        0 ~ 255
                                16-bits         i16            u16           ...
                                32-bits         i32            u32           ...
                                64-bits         i64            u64           ...
                                128-bits        i128           u128          ...
                                語法規律        i大小          u大小
                                __________________________________________________
                    
                    5. 除了 byte 以外，所有的數值都允許 使用型別後綴
                                示例: 57u8
                    
                    6. 整數型別預設是 i32

        2-4-2. 浮點數
                1. 單精度 => f32  位元數: 32
                2. 倍精度 => f64  位元數: 64

                3. 預設是 f64

        2-4-3. 布林值
                1. 關鍵字 bool
                2. 值: true, false
                3. 占用空間: 1-bit

        2-4-4. 字元
                1. char 型別被用來描述，語言中的 單個字元
                2. 字元 以 單引號 ( '' 號 ) 表示
                3. 編碼: Unicode
                4. 在 Unicode 編碼中沒有 "字元的概念"

        2-4-5. 複合型別
                1. Tuple (元組)
                        1-1. 可以將多個型別、多個值放在一個值裡
                        1-2. 長度是固定的，一旦宣告就 無法改變
                        1-3. 使用 () 號，值與值之間以 , 號分開
                        1-4. 取得 Tuple 的值: Tuple_名稱.索引值

                        示例: 
                              1 | let tup: (i32, f64, u8) = (500, 6.4, 1);
                              2 | let (x, y, z) = tup;   // 第 1 種
                              3 | x = tup.0; y = tup.1; z = tup.2;   // 取得 Tuple 內的元素

                2. 陣列
                        2-1. 也可以將多個型別、多個值放在一個值裡
                        2-2. 長度也是固定的
                        2-3. 每個元素 的 " 型別必須相同 "
                        2-4. 使用 [] 號，值與值之間以 , 號分開
                        2-5. 取得 陣列 的值: 陣列_名稱[索引值]
                        2-6. ** 注意事項 ** : 如果取值的索引超出陣列的範圍，那麼
                                              => 1. 編譯會通過
                                              => 2. 執行時會報錯 (出 bug，runtime 時會 panic)
                                                      ** Rust 不會允許其繼續訪問相應地址的記憶體空間 (內存)

                        示例: 
                              1 | let a[i32: 5] = [1, 2, 3, 4, 5];
                              2 |
                              3 | let x[3: 5];  // 若數值都相同，等同於下方這一行
                              4 | let x = [3, 3, 3, 3, 3];
 
3. 印出訊息 (或資料)
    3-1. 印出 hello world!
            執行印出字串 => println!("hello world!");
    
    3-2. 印出變數值 => println!("{} {} {}...", 變數 1, 變數 2, 變數 3, ...);
            3-2-1. 說明: 在 println!() 的 " " 號內，有 {} 號地方，
                                代表要輸出的變數。 
                        由左至右，從第 1 個 {} 號代表，第 1 個變數，以此類推

4. 取得用戶輸入
    4-1. 預導入 (prelude) 程式庫 => use 關鍵字
            4-1-1. 使用標準程式庫的功能: io 函式庫
                        use std::io;

    4-2. 讀取輸入資料 => io::stdin().read_line(&mut 變數名).expect("讀取失敗");
            4-2-1. 取得輸入的函式: stdin().read_line()
            4-2-2. 返回值，如下 3 點
                        1. Ok + 結果值
                        2. Err + 失敗原因
                        3. expect() : 若返回值為 Err，會中斷當前的運作，且把傳入的字串顯示出來
                                        反之，Ok 則會提取 附加的值，作為結果返回給使用者


5. 判斷式
    5-1. if 判斷式 (if statement)
            5-1-1. 單一條件、多條件 與 條件未成立
                        示例:
                              1 | let score = 80;
                              2 | 
                              3 | if score == 100 {
                              4 |    println!("學霸~");
                              5 | }
                              6 | else if score >= 60 {
                              7 |    println!("通過!");
                              8 | }
                              9 | else {
                             10 |    println!("不及格!!");
                             11 | }
                             12 |
                             13 | // 在 let 後方使用
                             14 | let flag = true;
                             15 | let result = if flag { 5 } else { 0 };


6. 迴圈
    6-1. loop 迴圈
            6-1-1. 簡介: 除非中斷程式執行，或 break; 關鍵字。 否則執行到天荒地老
                      示例 1: 第一種
                              1 | let mut x = 0;
                              2 | 
                              3 | loop {
                              4 |    if x == 100 {
                              5 |        break;   // 不加上，執行直到永遠(X
                              6 |    }
                              7 |    x += 1;
                              8 | }
                      
                      示例 2: 第二種 (loop 結束，指派給新的變數: break 指派數值;)
                              1 | let mut x = 0;
                              2 | 
                              3 | let result = loop {
                              4 |    if x == 100 {
                              5 |        break x * 2;   // 要指派給 result 的值
                              6 |    }
                              7 |    x += 1;
                              8 | };

    6-2. while 迴圈
            6-2-1. 簡介: 跟 C 語言家族、Java、JS... 差不多
                        示例: 印 num 從 1 ~ 9
                              1 | let mut num = 1;
                              2 | while num < 10 {
                              3 |    println!("{}", num);
                              4 |    num += 1;
                              5 | }


    6-3. for 迴圈
            6-3-1. 簡介: 跟 C 語言家族、Java、JS... 差不多 (...嗯?
                        示例: 印 num 從 1 ~ 9
                              1 | // C 語言家族、Java、JS... 是長這樣
                              2 | for (int i = 1; i < 10; i++) {
                              3 |    printf("%d", i);   // 這是 C 語言印資料 ㄉ...
                              4 | }
                              5 | 
                              6 | // Rust 是長這樣
                              7 | for i in 0..10 {
                              8 |    println!("{}", i);
                              9 | }
                             10 | 
                             11 | // 枚舉 (Enumerate)
                             12 | for (i, j) in (5..10).enumerate() {
                             13 |    // i 代表 圈數  j 代表 輸出數值 
                             14 |    println!("i = {}, j = {}", i, j);
                             15 | }
            
            6-3-2. for 迴圈 與 陣列 之操作結合
                        示例: 印陣列 nums 之所有元素
                              1 | // 宣告陣列
                              2 | let nums = [10, 20, 30, 40, 50, 60];
                              3 | 
                              4 | for element in nums.iter() {
                              5 |    println!("{}", element);
                              6 | }
                        
                        說明: nums.iter() 的 iter() 方法

                                在 nums 陣列下，iter() 方法，是屬於 "疊代器"
                                for 迴圈的循(淫)環(威)之下，則會依序從 iter() 取出 nums 的每一個值

                        示例: 把 1 ~ 3 的數值 倒反過來印出
                              1 | // 使用 rev() 方法
                              2 | for number in (1..4).rev() {
                              3 |    println!("{}", number);
                              4 | }
                              5 | println!("for 迴圈結束");

                        說明: for 的疊代資料 => ( 開始值 .. 結尾值(不包含) ).rev()
                                指定一個開始數值 和 一個結束數值，Range 可以生成它們之間的數值 (不包含結束)
                                使用 rev() 方法，可以反轉 Range


7. 函式宣告
    7-1. Rust 程式都至少有一個函式，main 函式，又稱主程式或進入點 (Entry Point)
                1 | fn main() {
                2 | }
        
    7-2. 自訂一個函式
                2-1. 沒有參數輸入
                        1 | fn foo() {
                        2 | }

                2-2. 含有參數
                        1 | fn print_number(x: i32) {
                        2 |     println!("x is: {}", x);
                        3 | }
    
    7-3. 含有參數的函式，注意事項
            7-3-1. 帶有多個參數的函式用逗號分開
                        1 | fn print_sum(x: i32, y: i32) {
                        2 |     println!("x + y = {}", x + y);
                        3 | }

            7-3-2. 參數型別必須明確指定
                    
                    以下為錯誤示範
                        1 | fn print_sum(x, y) {
                        2 |     println!("x + y = {}", x + y);
                        3 | }
    7-4. 回傳值函式
            7-4-1. 指定回傳值型別，在函式後方加上箭頭，並指定
                   箭頭的部分是用破折號 ( - 號) 加上 大於 ( > 號)

                   示例: 回傳兩數值相加結果
                        1 | fn add(x: i32, y: i32) -> i32 {
                        2 |     x + y
                        3 | }

                   從示例來看，兩個有趣的點
                        1. 在回傳值後方，並沒有使用 ; 號
                           如果加上 ; 號，編譯時會出現錯誤訊息

                           以下為錯誤示範
                                1 | fn add(x: i32, y: i32) -> i32 {
                                2 |     x + y;
                                3 | }
                        
                        2. Rust 是以表達式為基礎的語言，而分號的使用方式，
                           跟其他使用 大括號與分號 的語言，有不同之處

