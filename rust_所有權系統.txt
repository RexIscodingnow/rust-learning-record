三、 Rust 的核心特性: 所有權    (附註: "記憶體" 在以下內容，簡稱為: 內存)

1. 簡介: 所有程序在運行時，都必須管理 使用記憶體的方式

    1-1. 有些語言有 垃圾回收機制 (Garbage Collection)，它們會不斷尋找不再使用的記憶體
            ex: C#
    1-2. 而其他語言，必須 明確(手動) 分配與釋放記憶體
            ex: C/C++
    
    1-3. 不過 Rust 比較獨特，它讓 Rust 無需 Garbage Collection 就可以保證記憶體安全
         透過一個所有權系統來管理記憶體，其中包括一組編譯器在編譯時檢查的規則
         當程式執行時，所有權系統 "不會減慢運行速度"，因為 Rust 把這些工作提前到編譯時管理

2. Stack VS Heap

    2-1. Stack 介紹: 按順序接收資料儲存，按相反方向取出資料 (移除)
                        (特性: First In Last Out (簡稱: FILO)，先進後出)
            所有儲存在 Stack 上的資料必須是 "已知的固定大小"

    2-2. Heap 介紹: 編譯時，大小未知的資料，或是執行時資料大小會發生變化的，存放 Heap 上

            Heap 的記憶體組織性差一些，當資料放入 Heap 時會請求一定大小的空間
            當操作系統在 Heap 裡找到一個足夠大的空間，把它標記為在用，並返回一個指標，
            也就是 "記憶體位址" (學過 C/C++ 應該知道吧......)
            
            過程是在 Heap 上分配，稱為 "分配"

    2-3. 兩者比較

        2-3-1. Stack: 比 Heap 相對快得多
                由於 Stack 是已知固定大小，是 "分配"
                不過 指標 是已知固定大小，可以放入 Stack
                但是要 取得實際資料，必須用指標來取值

                因為操作系統不需要 尋找用來儲存新的資料的空間，只要從 Stack 頂端操作
        
        2-3-2. Heap: 分配空間，所需的工作較多
                而操作系統，需要先找到足夠大的空間來存放，並做好紀錄方便下次分配

    2-4. 存取資料
        
        2-4-1. 存取 Heap 比 Stack 慢，因為需要透過 指標 才能找到 Heap 中的資料
        2-4-2. 資料存取距離比較近，處理速度上會更快一些 (Stack)
        2-4-3. 反之，存放距離比較遠，速度上會慢一些 (Heap)
                    註: Heap 在分配大量的空間，也是需要時間

3. 所有權規則
    3-1. 每個值都有一個變數，這個變數是該值的所有者
    3-2. 每個值同時只能有一個所有者
    3-3. 當所有者 超出作用域 (scope) 時，該值將被刪除
                註: 作用域 (scope)，為 "變數的有效範圍"

4. String 類型

    4-1. String 比基本資料型別更複雜
    4-2. 字串字面值: 在程式裡手寫的字串值，它們是不可變的，是已經寫死在程式裡面
                        (主要是因為在編譯時，就已經分配好在 Stack 上)
    4-3. Rust 還有第二種字串類型: String
            在 Heap 上分配，能儲存在編譯時 "未知數量的文本"

    4-4. 宣告 String 類型的值
            4-4-1. 可以使用 from 函式從字串字面值，來宣告 String 類型
            
            示例:
                 1 | let s = String::from("hello world");    // :: 號表示 from 是 String 類型底下的函式
            
            4-4-2. 這類的 字串是可以被修改的

5. 內存 和 分配

    5-1. 字串字面值，是因為在編譯時，就已經知道內容大小，其文本內容直接硬編碼到最終可執行檔案
            因此速度快、高效，是因為 不可變性
    
    5-2. String 類型，為了支持可變性，需要在編譯時在 Heap 上分配未知大小的內存
            因此作業系統必須在運行時請求內存
                -- 在 String::from 來請求內存
            當用完 String 之後，需要將內存返回給作業系統
                -- 在擁有 GC 的語言中，GC 會跟蹤清理不再使用的內存
                -- 而沒有 GC 機制，就需要自己去識別內存何時不再使用，並調用代碼將其返回
                        1. 如果忘記釋放，則是浪費記憶體
                        2. 如果提前釋放，該變數就會變成非法
                        3. 如果做了兩次，也就是 Bug，則必須分配一次對應釋放一次

    5-3. 而 Rust 則採用了不同的方式，對於某些值，也就是當變數走出作用域(scope) 時，
                內存會立即 "自動交還給作業系統"
                
                -- 自動呼叫一個特殊函式: drop

    5-4. 變數與資料 的交互方式 => 移動 (Move)
            5-4-1. 說明: 多個變數可以與同一個資料，使用一種獨特的方來進行交互
            
            5-4-2. 整數資料示例

                示例:
                        1 | let x = 5;
                        2 | let y = x;

                說明: 整數是已知的且固定大小的數值，把這兩個 5 被壓到 Stack 中，
                        把 x 的值複製一份給 y

            5-4-3. String 類型示例

                示例:
                        1 | let s1 = String::from("hello");
                        2 | let s2 = s1;
                        3 | println!("s1: {}, world", s1);   // s1 離開 scope，視為無效，使用不了
                        4 | 
                        5 | println!("s2: {}, world", s2);
                   
                說明: 1. 一個 String 由 3 個部分組成
                                1. ptr: 一個指向存放字串內容的內存指標
                                2. len: 一個長度
                                3. capacity: 一個容量

                                -- 上方這 3 個部分放在 Stack 上
                                -- 存放字串內容的部分，在 Heap 上
                                -- 長度 len，就是存放字串內容所需要的字節數
                                -- 容量 capacity 是指 String 從作業系統總共獲得內存的總字節數

                      2. 當 s1 指派到 s2 時，String 的資料複製了一份:
                                -- 在 Stack 上複製一份 指標、長度、容量
                                -- 並沒有複製指標指向 Heap 上的資料
                      
                      3. 當變數離開 scope 時，Rust 會自動調用 drop 的函式，
                                將變數使用的 Heap 內存釋放
                         因此當 s1, s2 離開 scope 時，它們都會嘗試釋放相同內存
                                -- 二次釋放 (double free) Bug

                      4. 為了保證內存安全
                                -- Rust 沒有嘗試複製 被分配的內存
                                -- Rust 讓 s1 失效，也就是當 s1 離開 scope，Rust 不需要釋放任何東西

                圖示:
                              "s1"                 * Heap 上的資料 *           "s2"
                        | name     |val|           | index | val |      | name     |val|
                        |----------|---|           |-------|-----|      |----------|---|
                        | ptr      | --|---------> |   0   |  h  |      | ptr      | --|----> * Heap 上的資料 *
                        |----------|---|           |-------|-----|      |----------|---|        (參照左邊欄位)
                        | len      | 5 |           |   1   |  o  |      | len      | 5 |
                        |----------|---|           |-------|-----|      |----------|---|
                        | capacity | 5 |           |   2   |  l  |      | capacity | 5 |
                        |----------|---|           |-------|-----|      |----------|---|
                                                   |   3   |  l  |
                                                   |-------|-----|
                                                   |   4   |  o  |
                                                   |-------|-----|
            
            5-4-4. 所有權轉移(Move) 判斷基準
                
                1. 根據上方的 String 類型示例，將 s1 移動(Move) 到 s2
                   
                   ** 如果以其他語言來看，看起來像是把 "hello" 這個字串，複製一份過去 **
                   ** 而且 s1 與 s2 都可以使用，並不會編譯報錯 **
                                                -- C/C++, C#, Java, Python, ...之類的
                   
                   但在 Rust 的字串的資料結構(組成方式) *以字串為例子*
                        1. 一種是寫死固定: 字串字面值
                        2. 另一種是，可大小可變: String 類型
                   
                   第一種，因為是寫死固定(已知固定大小)，所以視為 複製特徵(Copy trait)，
                                因此賦值給其他變數，仍然可以使用

                   第二種，因為有在 Heap 上分配空間使用，視為可彈性大小，由於長度不定，
                            因此不視為 Copy trait，而是轉移該變數的所有權
                        
                        ** 把 s1 的資料複製到 s2，由於 s1 離開 scope，因此該變數也就視為無效 **
                
                2. 這裡有兩個專有名詞，有關於 Copy 的部分

                        2-1. 淺複製 / 淺拷貝 (shallow Copy)
                        2-2. 深複製 / 深拷貝 (deep Copy)

                        第一種，一般會將複製 指標、長度、容量 視為: 淺複製/淺拷貝，
                        但由於 Rust 讓 s1 失效，所以用 移動(Move)，比較合適

                        第二種，在 Rust 有一個隱含的設計原則: 不會自動創建資料的 深複製/深拷貝
                                -- 就運行時性能而言，任何自動賦值的操作都是廉價的

    5-5. 變數與資料 的交互方式 => 複製 / 克隆 (clone)
        
            5-5-1. 如果要對 Heap 上的 String 進行深度拷貝/複製，而不僅僅是 Stack 上的資料，
                        則可以使用 clone() 方法
                        
                示例:
                        1 | let s1 = String::from("hello");
                        2 | let s2 = s1.clone();
                        3 | println!("s1: {}, s2: {}", s1, s2);



